// +build ignore

package main

import (
	"bytes"
	"encoding/xml"
	"go/format"
	"io/ioutil"
	"log"
	"net/http"
	"os"
	"sort"
	"strings"
	"text/template"
)

func main() {
	if err := generateElements(); err != nil {
		log.Fatalf("%v", err)
	}
}

////////////////////////////////////////////////////////////////////////////////
// Elements
////////////////////////////////////////////////////////////////////////////////

type EBMLSchemaElement struct {
	Name       string `xml:"name,attr"`
	ID         string `xml:"id,attr"`
	Type       string `xml:"type,attr"`
	Deprecated bool   `xml:"-"`
}

type ElementsTable struct {
	XMLName  xml.Name             `xml:"EBMLSchema"`
	Elements []*EBMLSchemaElement `xml:"element"`
}

func generateElements() error {
	log.Printf("Downloading specification XML ...")
	var elements []*EBMLSchemaElement
	haveElement := map[string]bool{}
	for _, schema := range []string{
		"https://raw.githubusercontent.com/ietf-wg-cellar/ebml-specification/master/ebml.xml",
		"https://raw.githubusercontent.com/ietf-wg-cellar/matroska-specification/master/ebml_matroska.xml",
	} {
		resp, err := http.Get(schema)
		if err != nil {
			return err
		}
		defer resp.Body.Close()
		data, err := ioutil.ReadAll(resp.Body)
		// data, err := ioutil.ReadFile("specdata.xml")
		if err != nil {
			return err
		}
		table := ElementsTable{}
		err = xml.Unmarshal(data, &table)
		if err != nil {
			return err
		}
		for _, el := range table.Elements {
			if _, ok := haveElement[el.Name]; ok {
				continue
			}
			haveElement[el.Name] = true
			elements = append(elements, el)
		}
	}

	// Add legacy named fields
	elements = append(elements, []*EBMLSchemaElement{
		{Name: "ChapterTrackNumber", ID: "ChapterTrackUIDElement", Deprecated: true, Type: "uinteger"},
		{Name: "ReferenceTimeCode", ID: "ReferenceTimestampElement", Deprecated: true, Type: "uinteger"},
		{Name: "TimeCode", ID: "TimestampElement", Deprecated: true, Type: "uinteger"},
		{Name: "TimeCodeScale", ID: "TimestampScaleElement", Deprecated: true, Type: "uinteger"},
		{Name: "TrackTimeCodeScale", ID: "TrackTimestampScaleElement", Deprecated: true, Type: "float"},
	}...)

	log.Printf("Generating elements.go ...")

	for _, v := range elements {
		v.Name = strings.Replace(v.Name, "-", "", -1)
	}
	sort.Slice(elements, func(i, j int) bool {
		return strings.Compare(elements[i].Name+"Element", elements[j].Name+"Element") < 0
	})

	var buf bytes.Buffer
	if err := elementsTemplate.Execute(&buf, elements); err != nil {
		return err
	}

	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		return err
	}

	return os.WriteFile("elements.go", formatted, 0644)
}

var elementsTemplate = template.Must(template.New("").Parse(`// Code generated by generate.go.  DO NOT EDIT.

package mkvparse

// Supported ElementIDs
const (
	{{- range . }}
	{{ .Name }}Element ElementID = {{ .ID -}} {{- if .Deprecated -}}// Deprecated. Do not use.{{- end -}}
	{{end }}
)

var elementTypes = map[ElementID]elementType {
	{{- range . -}}
	{{- if not .Deprecated }}
	{{ .Name }}Element: 
		{{- if eq .Type "master" -}}
			masterType
		{{- else if eq .Type "uinteger" -}}
			uintegerType
		{{- else if eq .Type "integer" -}}
			integerType
		{{- else if eq .Type "binary" -}}
			binaryType
		{{- else if eq .Type "utf-8" -}}
			utf8Type
		{{- else if eq .Type "string" -}}
			stringType
		{{- else if eq .Type "float" -}}
			floatType
		{{- else if eq .Type "date" -}}
			dateType
		{{- end -}},
	{{- end -}}
	{{- end -}}
}

var elementNames = map[ElementID]string {
	{{- range . }}
	{{- if not .Deprecated }}
	{{ .Name }}Element: {{ printf "%q" .Name }},
	{{- end -}}
	{{- end -}}
}

`))
